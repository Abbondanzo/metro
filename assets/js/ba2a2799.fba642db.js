"use strict";(self.webpackChunkmetro_website=self.webpackChunkmetro_website||[]).push([[122],{3905:(e,n,t)=>{t.r(n),t.d(n,{MDXContext:()=>m,MDXProvider:()=>u,mdx:()=>x,useMDXComponents:()=>p,withMDXComponents:()=>s});var o=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(){return a=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o])}return e},a.apply(this,arguments)}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function d(e,n){if(null==e)return{};var t,o,i=function(e,n){if(null==e)return{};var t,o,i={},a=Object.keys(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var m=o.createContext({}),s=function(e){return function(n){var t=p(n.components);return o.createElement(e,a({},n,{components:t}))}},p=function(e){var n=o.useContext(m),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},u=function(e){var n=p(e.components);return o.createElement(m.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},h=o.forwardRef((function(e,n){var t=e.components,i=e.mdxType,a=e.originalType,r=e.parentName,m=d(e,["components","mdxType","originalType","parentName"]),s=p(t),u=i,h=s["".concat(r,".").concat(u)]||s[u]||c[u]||a;return t?o.createElement(h,l(l({ref:n},m),{},{components:t})):o.createElement(h,l({ref:n},m))}));function x(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var a=t.length,r=new Array(a);r[0]=h;var l={};for(var d in n)hasOwnProperty.call(n,d)&&(l[d]=n[d]);l.originalType=e,l.mdxType="string"==typeof e?e:i,r[1]=l;for(var m=2;m<a;m++)r[m]=t[m];return o.createElement.apply(null,r)}return o.createElement.apply(null,t)}h.displayName="MDXCreateElement"},15389:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>d,default:()=>c,frontMatter:()=>l,metadata:()=>m,toc:()=>p});var o=t(83117),i=t(80102),a=(t(67294),t(3905)),r=["components"],l={id:"configuration",title:"Configuring Metro"},d=void 0,m={unversionedId:"configuration",id:"configuration",title:"Configuring Metro",description:"A Metro config can be created in these three ways (ordered by priority):",source:"@site/../docs/Configuration.md",sourceDirName:".",slug:"/configuration",permalink:"/metro/docs/configuration",draft:!1,editUrl:"https://github.com/facebook/metro/edit/main/docs/../docs/Configuration.md",tags:[],version:"current",lastUpdatedAt:1665755512,formattedLastUpdatedAt:"Oct 14, 2022",frontMatter:{id:"configuration",title:"Configuring Metro"},sidebar:"docs",previous:{title:"API",permalink:"/metro/docs/api"},next:{title:"Metro CLI Options",permalink:"/metro/docs/cli"}},s={},p=[{value:"Configuration Structure",id:"configuration-structure",level:2},{value:"General Options",id:"general-options",level:3},{value:"<code>cacheStores</code>",id:"cachestores",level:4},{value:"<code>cacheVersion</code>",id:"cacheversion",level:4},{value:"<code>projectRoot</code>",id:"projectroot",level:4},{value:"<code>watchFolders</code>",id:"watchfolders",level:4},{value:"<code>transformerPath</code>",id:"transformerpath",level:4},{value:"<code>reporter</code>",id:"reporter",level:4},{value:"<code>resetCache</code>",id:"resetcache",level:4},{value:"<code>stickyWorkers</code>",id:"stickyworkers",level:4},{value:"<code>maxWorkers</code>",id:"maxworkers",level:4},{value:"<code>fileMapCacheDirectory</code>",id:"filemapcachedirectory",level:4},{value:"Deprecated: <code>hasteMapCacheDirectory</code>",id:"deprecated-hastemapcachedirectory",level:4},{value:"Resolver Options",id:"resolver-options",level:3},{value:"<code>assetExts</code>",id:"assetexts",level:4},{value:"<code>sourceExts</code>",id:"sourceexts",level:4},{value:"<code>resolverMainFields</code>",id:"resolvermainfields",level:4},{value:"<code>disableHierarchicalLookup</code>",id:"disablehierarchicallookup",level:4},{value:"<code>emptyModulePath</code>",id:"emptymodulepath",level:4},{value:"<code>extraNodeModules</code>",id:"extranodemodules",level:4},{value:"<code>nodeModulesPaths</code>",id:"nodemodulespaths",level:4},{value:"<code>resolveRequest</code>",id:"resolverequest",level:4},{value:"<code>useWatchman</code>",id:"usewatchman",level:4},{value:"<code>blockList</code>",id:"blocklist",level:4},{value:"<code>hasteImplModulePath</code>",id:"hasteimplmodulepath",level:4},{value:"<code>platforms</code>",id:"platforms",level:4},{value:"<code>requireCycleIgnorePatterns</code>",id:"requirecycleignorepatterns",level:4},{value:"Transformer Options",id:"transformer-options",level:3},{value:"<code>asyncRequireModulePath</code>",id:"asyncrequiremodulepath",level:4},{value:"<code>babelTransformerPath</code>",id:"babeltransformerpath",level:4},{value:"<code>dynamicDepsInPackages</code>",id:"dynamicdepsinpackages",level:4},{value:"<code>enableBabelRCLookup</code>",id:"enablebabelrclookup",level:4},{value:"<code>enableBabelRuntime</code>",id:"enablebabelruntime",level:4},{value:"<code>getTransformOptions</code>",id:"gettransformoptions",level:4},{value:"<code>hermesParser</code>",id:"hermesparser",level:4},{value:"<code>minifierPath</code>",id:"minifierpath",level:4},{value:"<code>minifierConfig</code>",id:"minifierconfig",level:4},{value:"<code>optimizationSizeLimit</code>",id:"optimizationsizelimit",level:4},{value:"React Native Only",id:"react-native-only",level:4},{value:"<code>assetPlugins</code>",id:"assetplugins",level:4},{value:"<code>assetRegistryPath</code>",id:"assetregistrypath",level:4},{value:"Serializer Options",id:"serializer-options",level:3},{value:"<code>getRunModuleStatement</code>",id:"getrunmodulestatement",level:4},{value:"<code>createModuleIdFactory</code>",id:"createmoduleidfactory",level:4},{value:"<code>getPolyfills</code>",id:"getpolyfills",level:4},{value:"<code>postProcessBundleSourcemap</code>",id:"postprocessbundlesourcemap",level:4},{value:"<code>getModulesRunBeforeMainModule</code>",id:"getmodulesrunbeforemainmodule",level:4},{value:"<code>processModuleFilter</code>",id:"processmodulefilter",level:4},{value:"Server Options",id:"server-options",level:3},{value:"<code>port</code>",id:"port",level:4},{value:"<code>useGlobalHotkey</code>",id:"useglobalhotkey",level:4},{value:"<code>enhanceMiddleware</code>",id:"enhancemiddleware",level:4},{value:"<code>rewriteRequestUrl</code>",id:"rewriterequesturl",level:4},{value:"<code>runInspectorProxy</code>",id:"runinspectorproxy",level:4},{value:"Watcher Options",id:"watcher-options",level:3},{value:"<code>additionalExts</code>",id:"additionalexts",level:4},{value:"<code>healthCheck.enabled</code>",id:"healthcheckenabled",level:4},{value:"<code>healthCheck.filePrefix</code>",id:"healthcheckfileprefix",level:4},{value:"<code>healthCheck.interval</code>",id:"healthcheckinterval",level:4},{value:"<code>healthCheck.timeout</code>",id:"healthchecktimeout",level:4},{value:"<code>watchman.deferStates</code>",id:"watchmandeferstates",level:4},{value:"Merging Configurations",id:"merging-configurations",level:2},{value:"Merging Example",id:"merging-example",level:4}],u={toc:p};function c(e){var n=e.components,t=(0,i.Z)(e,r);return(0,a.mdx)("wrapper",(0,o.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,a.mdx)("p",null,"A Metro config can be created in these three ways (ordered by priority):"),(0,a.mdx)("ol",null,(0,a.mdx)("li",{parentName:"ol"},(0,a.mdx)("inlineCode",{parentName:"li"},"metro.config.js")),(0,a.mdx)("li",{parentName:"ol"},(0,a.mdx)("inlineCode",{parentName:"li"},"metro.config.json")),(0,a.mdx)("li",{parentName:"ol"},"The ",(0,a.mdx)("inlineCode",{parentName:"li"},"metro")," field in ",(0,a.mdx)("inlineCode",{parentName:"li"},"package.json"))),(0,a.mdx)("p",null,"You can also give a custom file to the configuration by specifying ",(0,a.mdx)("inlineCode",{parentName:"p"},"--config <path/to/config>")," when calling the CLI."),(0,a.mdx)("admonition",{type:"note"},(0,a.mdx)("p",{parentName:"admonition"},"When Metro is started via the React Native CLI, some defaults are different from those mentioned below.\nSee the ",(0,a.mdx)("a",{parentName:"p",href:"https://github.com/react-native-community/cli/blob/master/packages/cli-plugin-metro/src/tools/loadMetroConfig.ts"},"React Native repository")," for details.")),(0,a.mdx)("h2",{id:"configuration-structure"},"Configuration Structure"),(0,a.mdx)("p",null,"The configuration is based on ",(0,a.mdx)("a",{parentName:"p",href:"/metro/docs/concepts"},"our concepts"),", which means that for every module we have a separate config option. A common configuration structure in Metro looks like this:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},"module.exports = {\n  /* general options */\n\n  resolver: {\n    /* resolver options */\n  },\n  transformer: {\n    /* transformer options */\n  },\n  serializer: {\n    /* serializer options */\n  },\n  server: {\n    /* server options */\n  },\n  watcher: {\n    /* watcher options */\n    watchman: {\n      /* Watchman-specific options */\n    }\n  }\n};\n")),(0,a.mdx)("h3",{id:"general-options"},"General Options"),(0,a.mdx)("h4",{id:"cachestores"},(0,a.mdx)("inlineCode",{parentName:"h4"},"cacheStores")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"Array<CacheStore<TransformResult<>>>")),(0,a.mdx)("p",null,"List where we store our ",(0,a.mdx)("a",{parentName:"p",href:"/metro/docs/caching"},"caches"),"."),(0,a.mdx)("h4",{id:"cacheversion"},(0,a.mdx)("inlineCode",{parentName:"h4"},"cacheVersion")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"string")),(0,a.mdx)("p",null,"Can be used to generate a key that will invalidate the whole metro cache."),(0,a.mdx)("h4",{id:"projectroot"},(0,a.mdx)("inlineCode",{parentName:"h4"},"projectRoot")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"string")),(0,a.mdx)("p",null,"The root folder of your project."),(0,a.mdx)("h4",{id:"watchfolders"},(0,a.mdx)("inlineCode",{parentName:"h4"},"watchFolders")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"Array<string>")),(0,a.mdx)("p",null,"Specify any additional (to projectRoot) watch folders, this is used to know which files to watch.\n(By default the file watching is disabled in CI environments. Also it can be manually disabled by setting the env variable ",(0,a.mdx)("inlineCode",{parentName:"p"},"CI=true"),")"),(0,a.mdx)("h4",{id:"transformerpath"},(0,a.mdx)("inlineCode",{parentName:"h4"},"transformerPath")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"string")),(0,a.mdx)("p",null,"The absolute path of a module (or a package name resolvable from the ",(0,a.mdx)("inlineCode",{parentName:"p"},"metro")," package) exporting a ",(0,a.mdx)("inlineCode",{parentName:"p"},"transform")," function."),(0,a.mdx)("h4",{id:"reporter"},(0,a.mdx)("inlineCode",{parentName:"h4"},"reporter")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"{update: () => void}")),(0,a.mdx)("p",null,"Used to report the status of the bundler during the bundling process."),(0,a.mdx)("h4",{id:"resetcache"},(0,a.mdx)("inlineCode",{parentName:"h4"},"resetCache")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"boolean")),(0,a.mdx)("p",null,"Whether we should reset the cache when starting the build."),(0,a.mdx)("h4",{id:"stickyworkers"},(0,a.mdx)("inlineCode",{parentName:"h4"},"stickyWorkers")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"boolean")),(0,a.mdx)("p",null,"Control whether the created workers should stick based on filename or not."),(0,a.mdx)("h4",{id:"maxworkers"},(0,a.mdx)("inlineCode",{parentName:"h4"},"maxWorkers")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"number")),(0,a.mdx)("p",null,"The number of workers we should parallelize the transformer on."),(0,a.mdx)("h4",{id:"filemapcachedirectory"},(0,a.mdx)("inlineCode",{parentName:"h4"},"fileMapCacheDirectory")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"string")),(0,a.mdx)("p",null,"The path to the ",(0,a.mdx)("inlineCode",{parentName:"p"},"metro-file-map")," cache directory, defaults to ",(0,a.mdx)("inlineCode",{parentName:"p"},"os.tmpdir()"),"."),(0,a.mdx)("h4",{id:"deprecated-hastemapcachedirectory"},"Deprecated: ",(0,a.mdx)("inlineCode",{parentName:"h4"},"hasteMapCacheDirectory")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"string")),(0,a.mdx)("p",null,"Alias of ",(0,a.mdx)("inlineCode",{parentName:"p"},"fileMapCacheDirectory")),(0,a.mdx)("hr",null),(0,a.mdx)("h3",{id:"resolver-options"},"Resolver Options"),(0,a.mdx)("h4",{id:"assetexts"},(0,a.mdx)("inlineCode",{parentName:"h4"},"assetExts")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"Array<string>")),(0,a.mdx)("p",null,"An array of asset extensions to include in the bundle. For example, if you would give ",(0,a.mdx)("inlineCode",{parentName:"p"},"['ttf']")," you would be able to include ",(0,a.mdx)("inlineCode",{parentName:"p"},".ttf")," files in the bundle."),(0,a.mdx)("h4",{id:"sourceexts"},(0,a.mdx)("inlineCode",{parentName:"h4"},"sourceExts")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"Array<string>")),(0,a.mdx)("p",null,"The list of source file extensions to include in the bundle. For example, including ",(0,a.mdx)("inlineCode",{parentName:"p"},"'ts'")," allows Metro to include ",(0,a.mdx)("inlineCode",{parentName:"p"},".ts")," files in the bundle."),(0,a.mdx)("p",null,"The order of these extensions defines the order to match files on disk. For more info, see ",(0,a.mdx)("a",{parentName:"p",href:"https://facebook.github.io/metro/docs/resolution"},"Module Resolution"),"."),(0,a.mdx)("p",null,"Defaults to ",(0,a.mdx)("inlineCode",{parentName:"p"},"['js', 'jsx', 'json', 'ts', 'tsx']"),"."),(0,a.mdx)("h4",{id:"resolvermainfields"},(0,a.mdx)("inlineCode",{parentName:"h4"},"resolverMainFields")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"Array<string>")),(0,a.mdx)("p",null,"Specify the fields in package.json files that will be used by the module resolver to do redirections when requiring certain packages. The default is ",(0,a.mdx)("inlineCode",{parentName:"p"},"['browser', 'main']"),", so the resolver will use the ",(0,a.mdx)("inlineCode",{parentName:"p"},"browser")," field if it exists and ",(0,a.mdx)("inlineCode",{parentName:"p"},"main")," otherwise."),(0,a.mdx)("admonition",{type:"note"},(0,a.mdx)("p",{parentName:"admonition"},"When Metro is started via the React Native CLI this will default to ",(0,a.mdx)("inlineCode",{parentName:"p"},"['react-native', 'browser', 'main']"),".")),(0,a.mdx)("h4",{id:"disablehierarchicallookup"},(0,a.mdx)("inlineCode",{parentName:"h4"},"disableHierarchicalLookup")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"boolean")),(0,a.mdx)("p",null,"Whether to disable ",(0,a.mdx)("a",{parentName:"p",href:"https://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders"},"looking up modules in ",(0,a.mdx)("inlineCode",{parentName:"a"},"node_modules")," folders"),". This only affects the default search through the directory tree, not other Metro options like ",(0,a.mdx)("inlineCode",{parentName:"p"},"extraNodeModules")," or ",(0,a.mdx)("inlineCode",{parentName:"p"},"nodeModulesPaths"),". Defaults to ",(0,a.mdx)("inlineCode",{parentName:"p"},"false"),"."),(0,a.mdx)("h4",{id:"emptymodulepath"},(0,a.mdx)("inlineCode",{parentName:"h4"},"emptyModulePath")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"string")),(0,a.mdx)("p",null,'What module to use as the canonical "empty" module when one is needed. Defaults to using the one included in ',(0,a.mdx)("inlineCode",{parentName:"p"},"metro-runtime"),". You only need to change this if Metro is installed outside of your project."),(0,a.mdx)("h4",{id:"extranodemodules"},(0,a.mdx)("inlineCode",{parentName:"h4"},"extraNodeModules")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"{[name:string]:string}")),(0,a.mdx)("p",null,"Which other ",(0,a.mdx)("inlineCode",{parentName:"p"},"node_modules")," to include besides the ones relative to the project directory. This is keyed by dependency name."),(0,a.mdx)("h4",{id:"nodemodulespaths"},(0,a.mdx)("inlineCode",{parentName:"h4"},"nodeModulesPaths")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"Array<string>")),(0,a.mdx)("p",null,"This option can be used to add additional ",(0,a.mdx)("inlineCode",{parentName:"p"},"node_modules")," folders for Metro to locate third-party dependencies when resolving modules. This is useful if third-party dependencies are installed in a different location outside of the direct path of source files."),(0,a.mdx)("p",null,"This option works similarly to how ",(0,a.mdx)("a",{parentName:"p",href:"https://nodejs.org/api/modules.html#modules_loading_from_the_global_folders"},"$NODE_PATH")," works for Node.js based tooling, except that ",(0,a.mdx)("inlineCode",{parentName:"p"},"nodeModulesPaths")," takes precedence over hierarchical ",(0,a.mdx)("inlineCode",{parentName:"p"},"node_modules")," lookup."),(0,a.mdx)("h4",{id:"resolverequest"},(0,a.mdx)("inlineCode",{parentName:"h4"},"resolveRequest")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"?CustomResolver")),(0,a.mdx)("p",null,"An optional function used to resolve requests. Particularly useful for cases where aliases or custom protocols are used. For example:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-javascript"},"resolveRequest: (context, moduleName, platform) => {\n  if (moduleName.startsWith('my-custom-resolver:')) {\n    // Resolve file path logic...\n    // NOTE: Throw an error if there is no resolution.\n    return {\n      filePath: 'path/to/file',\n      type: 'sourceFile',\n    };\n  }\n  // Optionally, chain to the standard Metro resolver.\n  return context.resolveRequest(context, moduleName, platform);\n}\n")),(0,a.mdx)("h4",{id:"usewatchman"},(0,a.mdx)("inlineCode",{parentName:"h4"},"useWatchman")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"boolean")),(0,a.mdx)("p",null,"If set to ",(0,a.mdx)("inlineCode",{parentName:"p"},"false"),", it'll prevent Metro from using watchman (even if it's installed)"),(0,a.mdx)("p",null,"These options are only useful with React Native projects."),(0,a.mdx)("h4",{id:"blocklist"},(0,a.mdx)("inlineCode",{parentName:"h4"},"blockList")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"RegExp")," or ",(0,a.mdx)("inlineCode",{parentName:"p"},"Array<RegExp>")),(0,a.mdx)("p",null,"A RegEx defining which paths to ignore, however if a blocklisted file is required it will be brought into the dependency graph."),(0,a.mdx)("h4",{id:"hasteimplmodulepath"},(0,a.mdx)("inlineCode",{parentName:"h4"},"hasteImplModulePath")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"string")),(0,a.mdx)("p",null,"The path to the haste resolver."),(0,a.mdx)("h4",{id:"platforms"},(0,a.mdx)("inlineCode",{parentName:"h4"},"platforms")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"Array<string>")),(0,a.mdx)("p",null,'Additional platforms to look out for, For example, if you want to add a "custom" platform, and use modules ending in .custom.js, you would return ',"['custom']"," here."),(0,a.mdx)("h4",{id:"requirecycleignorepatterns"},(0,a.mdx)("inlineCode",{parentName:"h4"},"requireCycleIgnorePatterns")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"Array<RegExp>")),(0,a.mdx)("p",null,"In development mode, suppress require cycle warnings for any cycle involving a module that matches any of these expressions. This is useful for third-party code and first-party expected cycles."),(0,a.mdx)("p",null,"Note that if you specify your own value for this config option it will replace (not concatenate with) Metro's default."),(0,a.mdx)("p",null,"Defaults to ",(0,a.mdx)("inlineCode",{parentName:"p"},"[/(^|\\/|\\\\)node_modules($|\\/|\\\\)/]"),"."),(0,a.mdx)("hr",null),(0,a.mdx)("h3",{id:"transformer-options"},"Transformer Options"),(0,a.mdx)("h4",{id:"asyncrequiremodulepath"},(0,a.mdx)("inlineCode",{parentName:"h4"},"asyncRequireModulePath")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"string")),(0,a.mdx)("p",null,"What module to use for handling async requires."),(0,a.mdx)("h4",{id:"babeltransformerpath"},(0,a.mdx)("inlineCode",{parentName:"h4"},"babelTransformerPath")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"string")),(0,a.mdx)("p",null,"Use a custom babel transformer (only relevant when using the default transformerPath). For example:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-javascript"},"// in your babelTransformer file\nmodule.exports = ({ filename, options, plugins, src }) => {\n  // transform file...\n  return { ast: AST };\n}\n")),(0,a.mdx)("h4",{id:"dynamicdepsinpackages"},(0,a.mdx)("inlineCode",{parentName:"h4"},"dynamicDepsInPackages")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"string")," (",(0,a.mdx)("inlineCode",{parentName:"p"},"throwAtRuntime")," or ",(0,a.mdx)("inlineCode",{parentName:"p"},"reject"),")"),(0,a.mdx)("p",null,"What should happen when a dynamic dependency is found."),(0,a.mdx)("h4",{id:"enablebabelrclookup"},(0,a.mdx)("inlineCode",{parentName:"h4"},"enableBabelRCLookup")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"boolean")," (default: ",(0,a.mdx)("inlineCode",{parentName:"p"},"true"),")"),(0,a.mdx)("p",null,"Whether we should use the ",(0,a.mdx)("inlineCode",{parentName:"p"},".babelrc")," config file."),(0,a.mdx)("h4",{id:"enablebabelruntime"},(0,a.mdx)("inlineCode",{parentName:"h4"},"enableBabelRuntime")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"boolean | string")," (default: ",(0,a.mdx)("inlineCode",{parentName:"p"},"true"),")"),(0,a.mdx)("p",null,"Whether the transformer should use the ",(0,a.mdx)("inlineCode",{parentName:"p"},"@babel/transform/runtime")," plugin."),(0,a.mdx)("p",null,"If the value is a string, it is treated as a runtime version number and passed as ",(0,a.mdx)("inlineCode",{parentName:"p"},"version")," to the ",(0,a.mdx)("inlineCode",{parentName:"p"},"@babel/plugin-transform-runtime")," configuration. This allows you to optimize the generated babel runtime based on the\nruntime in the app's node modules confugration."),(0,a.mdx)("h4",{id:"gettransformoptions"},(0,a.mdx)("inlineCode",{parentName:"h4"},"getTransformOptions")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"GetTransformOptions")),(0,a.mdx)("p",null,"Get the transform options."),(0,a.mdx)("h4",{id:"hermesparser"},(0,a.mdx)("inlineCode",{parentName:"h4"},"hermesParser")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"boolean")," (default: ",(0,a.mdx)("inlineCode",{parentName:"p"},"false"),")"),(0,a.mdx)("p",null,"Use the hermes-parser package to use call Hermes parser via WASM instead of the Babel parser."),(0,a.mdx)("h4",{id:"minifierpath"},(0,a.mdx)("inlineCode",{parentName:"h4"},"minifierPath")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"string")," (default: ",(0,a.mdx)("inlineCode",{parentName:"p"},"'metro-minify-terser'"),")"),(0,a.mdx)("p",null,"Path, or package name resolvable from ",(0,a.mdx)("inlineCode",{parentName:"p"},"metro-transform-worker"),", to the minifier that minifies the code after transformation."),(0,a.mdx)("h4",{id:"minifierconfig"},(0,a.mdx)("inlineCode",{parentName:"h4"},"minifierConfig")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"{[key: string]: mixed}")),(0,a.mdx)("p",null,"Configuration object that will be passed to the minifier (it should be serializable)."),(0,a.mdx)("h4",{id:"optimizationsizelimit"},(0,a.mdx)("inlineCode",{parentName:"h4"},"optimizationSizeLimit")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"number")),(0,a.mdx)("p",null,"Define a threshold (in bytes) to disable some expensive optimizations for big files."),(0,a.mdx)("h4",{id:"react-native-only"},"React Native Only"),(0,a.mdx)("h4",{id:"assetplugins"},(0,a.mdx)("inlineCode",{parentName:"h4"},"assetPlugins")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"Array<string>")),(0,a.mdx)("p",null,"List of modules to call to modify Asset data"),(0,a.mdx)("h4",{id:"assetregistrypath"},(0,a.mdx)("inlineCode",{parentName:"h4"},"assetRegistryPath")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"string")),(0,a.mdx)("p",null,"Where to fetch the assets from."),(0,a.mdx)("hr",null),(0,a.mdx)("h3",{id:"serializer-options"},"Serializer Options"),(0,a.mdx)("h4",{id:"getrunmodulestatement"},(0,a.mdx)("inlineCode",{parentName:"h4"},"getRunModuleStatement")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"(number")," ","|"," ",(0,a.mdx)("inlineCode",{parentName:"p"},"string) => string")),(0,a.mdx)("p",null,"Specify the format of the initial require statements that are appended at the end of the bundle. By default is ",(0,a.mdx)("inlineCode",{parentName:"p"},"__r(${moduleId});"),"."),(0,a.mdx)("h4",{id:"createmoduleidfactory"},(0,a.mdx)("inlineCode",{parentName:"h4"},"createModuleIdFactory")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"() => (path: string) => number")),(0,a.mdx)("p",null,"Used to generate the module id for ",(0,a.mdx)("inlineCode",{parentName:"p"},"require")," statements."),(0,a.mdx)("h4",{id:"getpolyfills"},(0,a.mdx)("inlineCode",{parentName:"h4"},"getPolyfills")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"({platform: ?string}) => $ReadOnlyArray<string>")),(0,a.mdx)("p",null,"An optional list of polyfills to include in the bundle. The list defaults to a set of common polyfills for Number, String, Array, Object..."),(0,a.mdx)("h4",{id:"postprocessbundlesourcemap"},(0,a.mdx)("inlineCode",{parentName:"h4"},"postProcessBundleSourcemap")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"PostProcessBundleSourcemap")),(0,a.mdx)("p",null,"An optional function that can modify the code and source map of the bundle before it is written. Applied once for the entire bundle."),(0,a.mdx)("h4",{id:"getmodulesrunbeforemainmodule"},(0,a.mdx)("inlineCode",{parentName:"h4"},"getModulesRunBeforeMainModule")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"(entryFilePath: string) => Array<string>")),(0,a.mdx)("p",null,"An array of modules to be required before the entry point. It should contain the absolute path of each module. Note that this will add the additional require statements only if the passed modules are already included as part of the bundle."),(0,a.mdx)("h4",{id:"processmodulefilter"},(0,a.mdx)("inlineCode",{parentName:"h4"},"processModuleFilter")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"(module: Array<Module>) => boolean")),(0,a.mdx)("p",null,"A filter function to discard specific modules from the output."),(0,a.mdx)("hr",null),(0,a.mdx)("h3",{id:"server-options"},"Server Options"),(0,a.mdx)("p",null,"These options are used when Metro serves the content."),(0,a.mdx)("h4",{id:"port"},(0,a.mdx)("inlineCode",{parentName:"h4"},"port")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"number")),(0,a.mdx)("p",null,"Which port to listen on."),(0,a.mdx)("h4",{id:"useglobalhotkey"},(0,a.mdx)("inlineCode",{parentName:"h4"},"useGlobalHotkey")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"boolean")),(0,a.mdx)("p",null,"Whether we should enable CMD+R hotkey for refreshing the bundle."),(0,a.mdx)("h4",{id:"enhancemiddleware"},(0,a.mdx)("inlineCode",{parentName:"h4"},"enhanceMiddleware")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"(Middleware, Server) => Middleware")),(0,a.mdx)("p",null,"The possibility to add custom middleware to the server response chain."),(0,a.mdx)("h4",{id:"rewriterequesturl"},(0,a.mdx)("inlineCode",{parentName:"h4"},"rewriteRequestUrl")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"string => string")),(0,a.mdx)("p",null,"A function that will be called every time Metro processes a URL. Metro will use the return value of this function as if it were the original URL provided by the client. This applies to all incoming HTTP requests (after any custom middleware), as well as bundle URLs in ",(0,a.mdx)("inlineCode",{parentName:"p"},"/symbolicate")," request payloads and within the hot reloading protocol."),(0,a.mdx)("h4",{id:"runinspectorproxy"},(0,a.mdx)("inlineCode",{parentName:"h4"},"runInspectorProxy")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"boolean")," (default: ",(0,a.mdx)("inlineCode",{parentName:"p"},"true"),")"),(0,a.mdx)("p",null,"Run Inspector Proxy server inside Metro to be able to inspect React Native code."),(0,a.mdx)("hr",null),(0,a.mdx)("h3",{id:"watcher-options"},"Watcher Options"),(0,a.mdx)("p",null,"Options for the filesystem watcher."),(0,a.mdx)("admonition",{type:"note"},(0,a.mdx)("p",{parentName:"admonition"},"Dot notation in this section indicates a nested configuration object, e.g. ",(0,a.mdx)("inlineCode",{parentName:"p"},"watchman.deferStates")," \u2192 ",(0,a.mdx)("inlineCode",{parentName:"p"},"watchman: { deferStates: ... }"),".")),(0,a.mdx)("h4",{id:"additionalexts"},(0,a.mdx)("inlineCode",{parentName:"h4"},"additionalExts")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"Array<string>")),(0,a.mdx)("p",null,"The extensions which Metro should watch in addition to ",(0,a.mdx)("inlineCode",{parentName:"p"},"sourceExts"),", but which will not be automatically tried by the resolver."),(0,a.mdx)("p",null,"Therefore, the two behaviour differences from ",(0,a.mdx)("inlineCode",{parentName:"p"},"resolver.sourceExts")," when importing a module are:"),(0,a.mdx)("ul",null,(0,a.mdx)("li",{parentName:"ul"},"Modules can only be required when fully specified (e.g. ",(0,a.mdx)("inlineCode",{parentName:"li"},"import moduleA from 'moduleA.mjs'"),")."),(0,a.mdx)("li",{parentName:"ul"},"No platform-specific resolution is performed.")),(0,a.mdx)("p",null,"Defaults to ",(0,a.mdx)("inlineCode",{parentName:"p"},"['cjs', 'mjs']"),"."),(0,a.mdx)("h4",{id:"healthcheckenabled"},(0,a.mdx)("inlineCode",{parentName:"h4"},"healthCheck.enabled")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"boolean")),(0,a.mdx)("p",null,"Whether to periodically check the health of the filesystem watcher by writing a temporary file to the project and waiting for it to be observed."),(0,a.mdx)("p",null,"The default value is ",(0,a.mdx)("inlineCode",{parentName:"p"},"false"),"."),(0,a.mdx)("h4",{id:"healthcheckfileprefix"},(0,a.mdx)("inlineCode",{parentName:"h4"},"healthCheck.filePrefix")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"string")),(0,a.mdx)("p",null,"If watcher health checks are enabled, this property controls the name of the temporary file that will be written into the project filesystem."),(0,a.mdx)("p",null,"The default value is ",(0,a.mdx)("inlineCode",{parentName:"p"},"'.metro-health-check'"),"."),(0,a.mdx)("admonition",{type:"note"},(0,a.mdx)("p",{parentName:"admonition"},"There's no need to commit health check files to source control. If you choose to enable health checks in your project, make sure you add ",(0,a.mdx)("inlineCode",{parentName:"p"},".metro-health-check*")," to your ",(0,a.mdx)("inlineCode",{parentName:"p"},".gitignore")," file to avoid generating unnecessary changes.")),(0,a.mdx)("h4",{id:"healthcheckinterval"},(0,a.mdx)("inlineCode",{parentName:"h4"},"healthCheck.interval")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"number")),(0,a.mdx)("p",null,"If watcher health checks are enabled, this property controls how often they occur (in milliseconds)."),(0,a.mdx)("p",null,"The default value is 30000."),(0,a.mdx)("h4",{id:"healthchecktimeout"},(0,a.mdx)("inlineCode",{parentName:"h4"},"healthCheck.timeout")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"number")),(0,a.mdx)("p",null,"If watcher health checks are enabled, this property controls the time (in milliseconds) Metro will wait for a file change to be observed before considering the check to have failed."),(0,a.mdx)("p",null,"The default value is 5000."),(0,a.mdx)("h4",{id:"watchmandeferstates"},(0,a.mdx)("inlineCode",{parentName:"h4"},"watchman.deferStates")),(0,a.mdx)("p",null,"Type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"Array<string>")),(0,a.mdx)("p",null,"Applies when using Watchman. Metro will ",(0,a.mdx)("a",{parentName:"p",href:"https://facebook.github.io/watchman/docs/cmd/subscribe.html#defer"},"defer processing filesystem updates")," while these ",(0,a.mdx)("a",{parentName:"p",href:"https://facebook.github.io/watchman/docs/cmd/state-enter.html"},"states")," are asserted in the watch. This is useful for debouncing builds while the filesystem hasn't settled, e.g. during large source control operations."),(0,a.mdx)("p",null,"The default value is ",(0,a.mdx)("inlineCode",{parentName:"p"},"['hg.update']"),"."),(0,a.mdx)("h2",{id:"merging-configurations"},"Merging Configurations"),(0,a.mdx)("p",null,"Using the ",(0,a.mdx)("inlineCode",{parentName:"p"},"metro-config")," package it is possible to merge multiple configurations together."),(0,a.mdx)("table",null,(0,a.mdx)("thead",{parentName:"table"},(0,a.mdx)("tr",{parentName:"thead"},(0,a.mdx)("th",{parentName:"tr",align:null},"Method"),(0,a.mdx)("th",{parentName:"tr",align:null},"Description"))),(0,a.mdx)("tbody",{parentName:"table"},(0,a.mdx)("tr",{parentName:"tbody"},(0,a.mdx)("td",{parentName:"tr",align:null},(0,a.mdx)("inlineCode",{parentName:"td"},"mergeConfig(...configs): MergedConfig")),(0,a.mdx)("td",{parentName:"tr",align:null},"Returns the merged configuration of two or more configuration objects.")))),(0,a.mdx)("admonition",{type:"note"},(0,a.mdx)("p",{parentName:"admonition"},"Arrays and function based config parameters do not deeply merge and will instead override any pre-existing config parameters.\nThis allows overriding and removing default config parameters such as ",(0,a.mdx)("inlineCode",{parentName:"p"},"platforms")," or ",(0,a.mdx)("inlineCode",{parentName:"p"},"getModulesRunBeforeMainModule")," that may not be required in your environment.")),(0,a.mdx)("h4",{id:"merging-example"},"Merging Example"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},"// metro.config.js\nconst { mergeConfig } = require('metro-config');\n\nconst configA = {\n  /* general options */\n\n  resolver: {\n    /* resolver options */\n  },\n  transformer: {\n    /* transformer options */\n  },\n  serializer: {\n    /* serializer options */\n  },\n  server: {\n    /* server options */\n  }\n};\n\nconst configB = {\n  /* general options */\n\n  resolver: {\n    /* resolver options */\n  },\n  transformer: {\n    /* transformer options */\n  },\n  serializer: {\n    /* serializer options */\n  },\n  server: {\n    /* server options */\n  }\n};\n\nmodule.exports = mergeConfig(configA, configB);\n")))}c.isMDXComponent=!0}}]);